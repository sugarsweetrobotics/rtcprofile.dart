library rtcprofile.base;

import 'package:xml/xml.dart' as xml;
import 'dart:core';
import 'namespaces.dart';
import 'basicinfo.dart';
import 'actions.dart';
import 'dataports.dart';
import 'serviceports.dart';
import 'configurations.dart';
import 'languages.dart';

/// RTCProfile class 
class RTCProfile {
  BasicInfo basicInfo;
  List<DataPorts> dataPorts;
  List<ServicePorts> servicePorts;
  ConfigurationSet configurationSet;
  Actions actions;
  Language language;
  
  List<DataPorts> get dataInPorts {
    List<DataPorts> ps = new List<DataPorts>();
    dataPorts.forEach((p) {
      if(p.portType == 'DataInPort') {
        ps.add(p);
      }
    });
    return ps;
  }
  
  List<DataPorts> get dataOutPorts {
    List<DataPorts> ps = new List<DataPorts>();
    dataPorts.forEach((p) {
      if(p.portType == 'DataOutPort') {
        ps.add(p);
      }
    });
    return ps;
  }
  
  RTCProfile() {
    dataPorts = new List<DataPorts>();
    servicePorts = new List<ServicePorts>();
    configurationSet = new ConfigurationSet();
  }
  
  static RTCProfile createFromText(String text) {
    xml.XmlDocument doc = xml.parse(text);
    return createFromXmlDocument(doc);
  }
  
  /// This fuction create RTCProfile class instance from XmlDocument data;
  /// If invalid Xml is passed, null is returned;
  static RTCProfile createFromXmlDocument(xml.XmlDocument doc) {
    var rtcp = new RTCProfile();
    doc.findAllElements('BasicInfo', namespace: ns_rtc).forEach((elem) {
      rtcp.basicInfo = BasicInfo.load(elem);
    });
    
    doc.findAllElements('Actions', namespace: ns_rtc).forEach((elem) {
      rtcp.actions = Actions.load(elem);
    });
    
    doc.findAllElements('ConfigurationSet', namespace: ns_rtc).forEach((elem) {
      rtcp.configurationSet = ConfigurationSet.load(elem);
    });
    
    doc.findAllElements('DataPorts', namespace: ns_rtc).forEach((elem) {
      rtcp.dataPorts.add(DataPorts.load(elem));
    });
    
    doc.findAllElements('ServicePorts', namespace: ns_rtc).forEach((elem) {
      rtcp.servicePorts.add(ServicePorts.load(elem));
    });
    
    doc.findAllElements('Language', namespace: ns_rtc).forEach((elem) {
      rtcp.language = Language.load(elem);
    });
    return rtcp;
  }
  
  String _getId() {
    return 'RTC:${basicInfo.vendor}:${basicInfo.category}:${basicInfo.name}:${basicInfo.version}';
  }
  
  /// buildXml
  /// This function returns XmlDocument object which generated by RTCProfile.
  xml.XmlDocument buildXml() {
    xml.XmlBuilder builder = new xml.XmlBuilder();
    builder.processing('xml', 'version="1.0" encoding="UTF-8" standalone="yes"');
    
    builder.element('RtcProfile', namespace: ns_rtc,
      namespaces: {ns_rtc: 'rtc', ns_rtcDoc: 'rtcDoc', ns_rtcExt: 'rtcExt', ns_xsi: 'xsi'}, 
      attributes: {'rtc:version': '0.2', 'rtc:id': _getId()},
      nest : () {
        basicInfo.buildXml(builder);
        actions.buildXml(builder);
        if(configurationSet != null) {
           configurationSet.buildXml(builder);
        }
        dataPorts.forEach((p) {
          p.buildXml(builder);
        });

        servicePorts.forEach((p) {
          p.buildXml(builder);
        });
        
        language.buildXml(builder);
    });
    return builder.build();
  }
  
  String toString() {
    return buildXml().toXmlString(pretty: true);
  }
  
  RTCProfile clone() {
    xml.XmlDocument doc = this.buildXml();
    return RTCProfile.createFromXmlDocument(doc);
  }
}